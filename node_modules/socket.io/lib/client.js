
//Module dependencies.
var parser = require('socket.io-parser');
var debug = require('debug')('socket.io:client');

//Module exports.
module.exports = Client;

// Client constructor.
 
function Client(server, conn){
  this.server = server;
  this.conn = conn;
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.id = conn.id;
  this.request = conn.request;
  this.setup();
  this.sockets = [];
  this.nsps = {};
  this.connectBuffer = [];
}

//Sets up event listeners.
 
Client.prototype.setup = function(){
  this.onclose = this.onclose.bind(this);
  this.ondata = this.ondata.bind(this);
  this.onerror = this.onerror.bind(this);
  this.ondecoded = this.ondecoded.bind(this);

  this.decoder.on('decoded', this.ondecoded);
  this.conn.on('data', this.ondata);
  this.conn.on('error', this.onerror);
  this.conn.on('close', this.onclose);
};

//Connects client to namespace.

Client.prototype.connect = function(name){
  debug('Connecting to Namespace %s', name);
  if (!this.server.nsps[name]) {
    this.packet({ type: parser.ERROR, nsp: name, data : 'Invalid Namespace'});
    return;
  }
  var nsp = this.server.of(name);
  if ('/' != name && !this.nsps['/']) {
    this.connectBuffer.push(name);
    return;
  }

  var self = this;
  var socket = nsp.add(this, function(){
    self.sockets.push(socket);
    self.nsps[nsp.name] = socket;

    if ('/' == nsp.name && self.connectBuffer.length > 0) {
      self.connectBuffer.forEach(self.connect, self);
      self.connectBuffer = [];
    }
  });
};

//Disconnects from all namespaces and closes transport.

Client.prototype.disconnect = function(){
  var socket;
  while (socket = this.sockets.shift()) {
    socket.disconnect();
  }
  this.close();
};

//Removes a socket. Called by each `Socket`.


Client.prototype.remove = function(socket){
  var i = this.sockets.indexOf(socket);
  if (~i) {
    var nsp = this.sockets[i].nsp.name;
    this.sockets.splice(i, 1);
    delete this.nsps[nsp];
  } else {
    debug('ignoring remove for %s', socket.id);
  }
};

//Closes the underlying connection.

Client.prototype.close = function(){
  if ('open' == this.conn.readyState) {
    debug('forcing transport close');
    this.conn.close();
    this.onclose('forced server close');
  }
};

//Writes a packet to the transport.

Client.prototype.packet = function(packet, preEncoded, volatile){
  var self = this;

  // this writes to the actual connection
  function writeToEngine(encodedPackets) {
    if (volatile && !self.conn.transport.writable) return;
    for (var i = 0; i < encodedPackets.length; i++) {
      self.conn.write(encodedPackets[i]);
    }
  }

  if ('open' == this.conn.readyState) {
    debug('writing packet %j', packet);
    if(!preEncoded) {
      this.encoder.encode(packet, function (encodedPackets) { // encode, then write results to engine
        writeToEngine(encodedPackets);
      });
    } else { 
      writeToEngine(packet);
    }
  } else {
    debug('Ignoring packet write %j', packet);
  }
};

//Called with incoming transport data.

Client.prototype.ondata = function(data){
  // try and catch is needed for protocol violations (GH-1880)
  try {
    this.decoder.add(data);
  } catch(e) {
    this.onerror(e);
  }
};

//Called when parser fully decodes a packet.

Client.prototype.ondecoded = function(packet) {
  if (parser.CONNECT == packet.type) {
    this.connect(packet.nsp);
  } else {
    var socket = this.nsps[packet.nsp];
    if (socket) {
      socket.onpacket(packet);
    } else {
      debug('No socket present for namespace %s', packet.nsp);
    }
  }
};

//Handles an error.

Client.prototype.onerror = function(err){
  this.sockets.forEach(function(socket){
    socket.onerror(err);
  });
  this.onclose('client error');
};

//Called upon transport close.

Client.prototype.onclose = function(reason){
  debug('Client is closed with reason %s', reason);

  this.destroy();

  var socket;
  while (socket = this.sockets.shift()) {
    socket.onclose(reason);
  }

  this.decoder.destroy();
};

//Cleans up event listeners.

Client.prototype.destroy = function(){
  this.conn.removeListener('data', this.ondata);
  this.conn.removeListener('error', this.onerror);
  this.conn.removeListener('close', this.onclose);
  this.decoder.removeListener('decoded', this.ondecoded);
};
